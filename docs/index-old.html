<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Overview - Aphrodite</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/tufte.css">
<link rel="stylesheet" href="/main.css">
<link rel="stylesheet" href="/docs/index.css">

<meta name="description" content="Aphrodite is a schema layer whose first goal is to make P2P &#x26; Local-First software as easy to develop as traditional client-server software. You can think of Aphrodite as an ORM of sorts that is designed for the needs of Local-First applications and P2P…">
<meta name="keywords" content="software, schemas, data">
<meta name="author" content="Matt Wonlaw">
<meta name="copyright" content="© 2022 Matt Wonlaw">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Aphrodite">
<meta property="og:title" content="Overview">
<meta property="og:description" content="Aphrodite is a schema layer whose first goal is to make P2P &#x26; Local-First software as easy to develop as traditional client-server software. You can think of Aphrodite as an ORM of sorts that is designed for the needs of Local-First applications and P2P…">
<meta property="og:image" content="https://aphrodite.sh/assets/gods/hephaestus.svg">
<meta property="og:image:alt" content="Hephaestus">
<meta property="og:image:width" content="192">
<meta property="og:image:height" content="411">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://aphrodite.sh/assets/gods/hephaestus.svg">
<meta name="twitter:image:alt" content="Hephaestus">
<meta name="twitter:site" content="@tantaman">
<meta name="twitter:label1" content="Reading time">
<meta name="twitter:data1" content="6-9 minutes">
</head>
<body><aside><div class="center"><a class="home-link" href="/"><div class="god-circle center-block"><div class="god-head god-head-aphrodite"></div></div></a></div></aside><main><article><section>
<nav class="toc"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#overview">Overview</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#schema">Schema</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#queries">Queries</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#mutations">Mutations</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#p2p">P2P</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#data-consistency">Data Consistency</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#schema-replication">Schema Replication</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#migrations">Migrations</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#privacy">Privacy</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#polyglot-storage--server-side">Polyglot Storage &#x26; Server Side</a></li></ol></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#current-implementation">Current Implementation</a></li></ol></nav><p><a href="https://github.com/tantaman/aphrodite" style="position: absolute; top: 0; right: 0;"><img loading="lazy" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_green_007200.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a></p>
<p><code>Aphrodite</code> is a schema layer whose first goal is to make <a href="https://en.wikipedia.org/wiki/Peer-to-peer">P2P</a> &#x26; <a href="https://www.inkandswitch.com/local-first/">Local-First</a> software as easy to develop as traditional client-server software.</p>
<p>You can think of <code>Aphrodite</code> as an <code>ORM</code> of sorts that is designed for the needs of <a href="https://www.inkandswitch.com/local-first/">Local-First</a> applications and <a href="https://en.wikipedia.org/wiki/Peer-to-peer">P2P</a> data transfer.</p>
<h1 id="overview"><a aria-hidden="true" tabindex="-1" href="#overview"><span class="icon icon-link"></span></a>Overview</h1>
<p>The core of any application is its data and the consistency of that data. As such, everything in <code>Aphrodite</code> begins with a schema. This schema encodes the application's data, its relationships, consistency rules, allowed mutations and privacy.</p>
<h2 id="schema"><a aria-hidden="true" tabindex="-1" href="#schema"><span class="icon icon-link"></span></a>Schema</h2>
<p><code>Aphrodite</code> Schemas are written in a <code>DSL</code>. This <code>DSL</code> describes the <code>nodes</code> and <code>edges</code> that make up the application's data model. The schema can represent graph or relational data models.</p>
<p><strong>Example</strong></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>&#x3C;<span class="hljs-title class_">User</span>>
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">NaturalLanguage</span>
  <span class="hljs-attr">created</span>: <span class="hljs-title class_">Timestamp</span>
  <span class="hljs-attr">modified</span>: <span class="hljs-title class_">Timestamp</span>
} &#x26; <span class="hljs-title class_">OutboundEdges</span> {
  <span class="hljs-attr">todos</span>: <span class="hljs-title class_">Edge</span>&#x3C;<span class="hljs-title class_">Todo</span>.<span class="hljs-property">ownerId</span>>
}

<span class="hljs-title class_">Todo</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>&#x3C;<span class="hljs-title class_">Todo</span>>
  <span class="hljs-attr">text</span>: <span class="hljs-title class_">NaturalLanguage</span>
  <span class="hljs-attr">completed</span>: <span class="hljs-title class_">Timestamp</span> | <span class="hljs-literal">null</span>
  <span class="hljs-attr">created</span>: <span class="hljs-title class_">Timestamp</span>
  <span class="hljs-attr">modified</span>: <span class="hljs-title class_">Timestamp</span>
  <span class="hljs-attr">ownerId</span>: <span class="hljs-variable constant_">ID</span>&#x3C;<span class="hljs-title class_">User</span>>
} &#x26; <span class="hljs-title class_">OutboundEdges</span> {
  <span class="hljs-attr">owner</span>: <span class="hljs-title class_">Edge</span>&#x3C;ownerId>
}
</code></pre>
<p>From the schema definition, <code>Aphrodite</code> generates <code>TypeScript</code> (and eventually other target languages) classes to interact with your data.</p>
<h2 id="queries"><a aria-hidden="true" tabindex="-1" href="#queries"><span class="icon icon-link"></span></a>Queries</h2>
<p>Queries allow you to load, find and join your data in arbitrary ways.</p>
<p>To support local first development, all queries against your data can be made reactive. Also to support local first, all components that view a given piece of data will always see the latest version of that data unless they explicitly and overtly decide not to.</p>
<p><strong>Load and Query</strong></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">load</span>(<span class="hljs-string">`user-id`</span>);
<span class="hljs-keyword">const</span> todos = <span class="hljs-keyword">await</span> user.<span class="hljs-title function_">queryTodos</span>().<span class="hljs-title function_">gen</span>();

<span class="hljs-keyword">const</span> liveCompletedTodos = user.<span class="hljs-title function_">queryTodos</span>().<span class="hljs-title function_">whereCompleted</span>(P.<span class="hljs-title function_">notEqual</span>(<span class="hljs-literal">null</span>)).<span class="hljs-title function_">live</span>();

liveCompletedTodos.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">completed</span>) =></span> ...);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params">{user}: {user: User}</span>) {
  <span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useQuery</span>(<span class="hljs-function">() =></span> user.<span class="hljs-title function_">queryTodos</span>().<span class="hljs-title function_">live</span>());
  <span class="hljs-keyword">return</span> todos.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =></span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Todo</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span> /></span></span>);
}
</code></pre>
<h2 id="mutations"><a aria-hidden="true" tabindex="-1" href="#mutations"><span class="icon icon-link"></span></a>Mutations</h2>
<p>Before you can query any data you need to create it. <code>Aphrodite</code> supports mutation primitives to allow you to do this in a safe and declarative way.</p>
<p>To ensure your app never sees transient state, <code>Aphrodite</code> has concepts of <code>mutators</code>, <code>changesets</code> and <code>transactions</code>. These allow you to describe a change in full and then commit those changes all at once. Valid mutations can be declared on the schema to allow programmatic discovery of operations against your data (inspired by <a href="https://blockprotocol.org/">Block Protocl</a> and A Protocol for Integrations (<a href="https://github.com/tantaman/tantaman.github.io/blob/master/_drafts/2022-01-26-protocol-for-integrations.markdown">draft post</a>).</p>
<p><strong>Declare Mutations</strong></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Todo</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span> {
  ...
} &#x26; <span class="hljs-title class_">OutboundEdges</span> {
  ...
} &#x26; <span class="hljs-title class_">Mutations</span> {
  create {
    text
  }
  complete
  uncomplete
}
</code></pre>
<p><strong>Transactions</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> mutation = <span class="hljs-title class_">TodoMutations</span>.<span class="hljs-title function_">create</span>(viewer, <span class="hljs-string">'My first todo which is already done!'</span>).<span class="hljs-title function_">complete</span>();

<span class="hljs-comment">// We can either commit the mutation now</span>
<span class="hljs-keyword">await</span> mutation.<span class="hljs-title function_">save</span>();

<span class="hljs-comment">// Or we can batch it with other mutations that should be commited all at once</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">commit</span>(mutation.<span class="hljs-title function_">toChangeset</span>(), <span class="hljs-title class_">TodoMutation</span>.<span class="hljs-title function_">create</span>(viewer, <span class="hljs-string">'My second todo!'</span>).<span class="hljs-title function_">toChangeset</span>());
</code></pre>
<p>You can collect as many mutations to your application's state as you want before finally committing them all together. Rather than opening a transaction at one line of code and committing it at another, you collect changesets. Once you have all the changes you want you commit them together.</p>
<h2 id="p2p"><a aria-hidden="true" tabindex="-1" href="#p2p"><span class="icon icon-link"></span></a>P2P</h2>
<p>To support syncing, you can opt your data models into <code>P2P</code> replication and declare what <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict free replicated data type</a> (CRDTs) to use under the hood to merge state across peers.</p>
<p><strong>Example Replication Declarations</strong></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Todo</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span> {
  ...
} &#x26; <span class="hljs-title class_">Replication</span> {
  <span class="hljs-title class_">ColumnLevel</span> {
    lastWriteWins
  }
  <span class="hljs-title class_">Clock</span> {
    <span class="hljs-title class_">Logical</span>
  }
}

-or-

<span class="hljs-title class_">Todo</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span> {
  ...
} &#x26; <span class="hljs-title class_">Replication</span> {
  <span class="hljs-title class_">InstanceLevel</span> {
    lastWriteWins
  }
  <span class="hljs-title class_">Clock</span> {
    <span class="hljs-title class_">HybridLogical</span> {
      <span class="hljs-attr">resolution</span>: 60s
    }
  }
}
</code></pre>
<p><strong>Note</strong> -- P2P syncing via CRDTs does not support transactions fully. You can create and commit a transaction on one client but, due to the nature of CRDTs, other clients may not accept the full contents of the transaction. So how do we ensure data consistency in the face of this?</p>
<h2 id="data-consistency"><a aria-hidden="true" tabindex="-1" href="#data-consistency"><span class="icon icon-link"></span></a>Data Consistency</h2>
<p>Developers can define integrity constraints on their schemas. When a replicated update is received that violates the constraint, a new state update is added that rolls back the update. This feature is still in the research phase to understand what constraints and rollbacks can be supported in a p2p environment without causing state loops amongst peers.</p>
<p>The data consistency ideas are part inspired by <a href="https://hal.inria.fr/hal-02983557/document">Conflict Free Replicated Relations</a> and the internal <code>Ent Integrity</code> project at <a href="https://engineering.fb.com/">Meta</a>.</p>
<h2 id="schema-replication"><a aria-hidden="true" tabindex="-1" href="#schema-replication"><span class="icon icon-link"></span></a>Schema Replication</h2>
<p>In a distributed system, every peer could be running a different version of your software. This makes schemas all the more important. By having you data schematized, we can understand which clients and which pieces of data are ahead or behind in terms of data format.</p>
<p>A peer whose data format is behind another peer's would cause problems if they tried to replicate changes to one another. One peer may have consistency rules that another does not. One peer may have fields removed from their schema that another has added. To combat this, <code>Aphrodite</code> pushes schema replications to auto-upgrade all peers to the greatest common version of a schema before replicating data controlled by that schema.</p>
<p>Schema version changes brings us to the next topic -- data migrations.</p>
<h2 id="migrations"><a aria-hidden="true" tabindex="-1" href="#migrations"><span class="icon icon-link"></span></a>Migrations</h2>
<p>Migrations between schema versions are encoded into <code>Aphrodite</code> schemas.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Todo</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span> {
  <span class="hljs-attr">id</span>: ID_of&#x3C;<span class="hljs-title class_">Todo</span>>
  <span class="hljs-attr">text</span>: <span class="hljs-title class_">NaturalLanguage</span>
  <span class="hljs-attr">completed</span>: boolean
} &#x26; <span class="hljs-title class_">Migrations</span> {
  <span class="hljs-attr">v1</span>: {
    completedTime {
      <span class="hljs-attr">priorField</span>: completed
      <span class="hljs-attr">newField</span>: <span class="hljs-title class_">Timestamp</span> | <span class="hljs-literal">null</span>
      <span class="hljs-attr">convert</span>: <span class="hljs-function">(<span class="hljs-params">oldValue</span>) =></span> oldValue ? <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() : <span class="hljs-literal">null</span>
    }
  }
}
</code></pre>
<p>All migration definitions are retained so any peer that joins a network can have their schema moved through the successive versions until it is up to date.</p>
<p>There are issues for very large datasets to consider as migrating billions of rows is not instant. We have a few plans to address this:</p>
<ol>
<li>For traditional server type deployments, allow mechanisms such as taking a db replica offline to run migrations then bringing it back online, catching it up then swapping it to master</li>
<li>Allow migrations to be run lazily. I.e., apply the migration functions as needed as data is loaded by the application. This will only work for a subset of migration types.</li>
</ol>
<h2 id="privacy"><a aria-hidden="true" tabindex="-1" href="#privacy"><span class="icon icon-link"></span></a>Privacy</h2>
<p>You may have noticed references to <code>owner</code> and <code>viewer</code> in the example code. This is because <code>Aphrodite</code> supports privacy on data even though it targets local first development.</p>
<p>Imagine you have a local first app but your users want to be able to share parts of their local data with others. Your user's data shouldn't be replicated to just anyone. There need to be privacy controls in place to determine what users receive what updates.</p>
<p><code>Aphrodite</code> allows you to declare these rules on the schema itself or, when they're more complicated, within <code>TypeScript</code>.</p>
<p>The rules are run any time data is loaded and any time is it being replicated across the network to a peer. Mutation rules can also be enable to allow read access but not write or vice-versa.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Todo</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-variable constant_">ID</span>&#x3C;<span class="hljs-title class_">Todo</span>>
  <span class="hljs-attr">text</span>: <span class="hljs-title class_">NaturalLanguage</span>
  <span class="hljs-attr">completed</span>: <span class="hljs-title class_">Timestamp</span> | <span class="hljs-literal">null</span>
  <span class="hljs-attr">ownerId</span>: <span class="hljs-variable constant_">ID</span>&#x3C;<span class="hljs-title class_">User</span>>
} &#x26; <span class="hljs-title class_">Edges</span> {
  <span class="hljs-attr">sharedWith</span>: <span class="hljs-title class_">JunctionEdge</span>&#x3C;<span class="hljs-title class_">Todo</span>, <span class="hljs-title class_">User</span>>
} &#x26; <span class="hljs-title class_">ReadPrivacy</span> {
  <span class="hljs-title class_">AllowIf</span>(<span class="hljs-function">(<span class="hljs-params">viewer, todo</span>) =></span> todo.<span class="hljs-property">ownerId</span> === viewer.<span class="hljs-property">id</span>),
  <span class="hljs-title class_">AllowIf</span>(<span class="hljs-function">(<span class="hljs-params">viewer, todo</span>) =></span> todo.<span class="hljs-title function_">querySharedWith</span>().<span class="hljs-title function_">whereId</span>(P.<span class="hljs-title function_">equals</span>(viewer.<span class="hljs-property">id</span>)).<span class="hljs-title function_">exists</span>())
  <span class="hljs-title class_">AlwaysDeny</span>
}
</code></pre>
<p>Write rules can be added to allow peers to reject incoming changes to data they don't want updated.</p>
<h2 id="polyglot-storage--server-side"><a aria-hidden="true" tabindex="-1" href="#polyglot-storage--server-side"><span class="icon icon-link"></span></a>Polyglot Storage &#x26; Server Side</h2>
<p><code>Aphrodite</code> isn't constrainted to local first software. It can act as a fully featured <code>ORM</code> for backends as well and allows traditional client-server development in addition to p2p applications.</p>
<p><code>Aphrodite</code> will also support joins across different storage layers. E.g., traversing edges between <code>SQL</code>, <code>Redis</code>, <code>Neo4j</code> rows. This is done via <a href="https://gist.github.com/tantaman/bd928ef93619e73365b07899da282996#aside---traversing-across-storage-backends">ChunkIterables</a> and <a href="https://github.com/tantaman/aphrodite/blob/main/packages/query-runtime-ts/src/HopPlan.ts">HopPlans</a>.</p>
<h1 id="current-implementation"><a aria-hidden="true" tabindex="-1" href="#current-implementation"><span class="icon icon-link"></span></a>Current Implementation</h1>
<p><code>Aphrodite</code> is under active development here: <a href="https://github.com/tantaman/aphrodite">https://github.com/tantaman/aphrodite</a></p>
<p>A TodoMVC example app that uses Aphrodite is under development here: <a href="https://github.com/tantaman/aphrodite/tree/main/examples/todo-mvc">https://github.com/tantaman/aphrodite/tree/main/examples/todo-mvc</a></p>
<p>It <strong>is not</strong> ready for release.</p>
<p>Integration tests to show the various described use cases are being built out here: <a href="https://github.com/tantaman/aphrodite/blob/main/packages/integration-tests-ts/src/__tests__/">https://github.com/tantaman/aphrodite/blob/main/packages/integration-tests-ts/src/<strong>tests</strong>/</a> (and up a dir)</p>
<script src="https://www.googletagmanager.com/gtag/js?id=G-QT6QH0ZJQ4" async></script>
<script src="/ga.js"></script>
<script src="/assets/god-switcher.js"></script>
</section></article></main></body>
</html>
